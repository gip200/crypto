#!/usr/bin/env python3

#from nacl.secret import SecretBox
#from nacl.exceptions import CryptoError
import sys
import json
import math
import binascii
import secrets
import random
from Crypto.Cipher import AES

def lcm(a,b):
	return abs(a*b) // math.gcd(a, b)

def modinv(e,l):
	for x in range(1,l):
		if (e * x) % l == 1:
			return x
	raise Exception("No inverse found")


inputs = json.load(sys.stdin)
outputs = {}


## problem 1
##
##   "problem 1":
##        {
##            "nums": [3, 4, 5, 6]
##        },
##
##  OUTPUT:     "problem 1" : [true, false, true, false],


#### code adapted from https://www.programiz.com/python-programming/examples/prime-number
nums = (inputs["problem 1"]["nums"])
output_string_1 = []

for index1 in range(len(nums)):
    num = nums[index1]
    #print(num)
    # define a flag variable
    flag = True

    # prime numbers are greater than 1
    if num > 1:
        # check for factors
        for i in range(2, num):
            if (num % i) == 0:
                # if factor is found, set flag to false, its not prime
                flag = False
                # break out of loop
                break

    output_string_1.append(flag)

#print(output_string_1)
outputs["problem 1"] = output_string_1


## problem 2
##
##   "problem 2":
##      {
##        "p": 7,
##        "q": 11
##       },
##
##  OUTPUT:     "problem 2" : 7,

p = (inputs["problem 2"]["p"])
q = (inputs["problem 2"]["q"])
output2=''

# inspiration from https://crypto.stackexchange.com/questions/13166/method-to-calculating-e-in-rsa
n = p * q
l = lcm(p - 1, q - 1)

e_list = []
e = 2

while e < l:
    if math.gcd(e, l) == 1:
        e_list.append(e)
        e = e + 1
    else:
        e = e + 1

#take smallest prime of e_list
small_e = e_list[0]

#print(output2)
outputs["problem 2"] = small_e


## problem 3
##
## "problem 3":
##    {
##      "p": 7,
##      "q": 11
##    },
##  OUTPUT:     "problem 3" : 13,

p = (inputs["problem 3"]["p"])
q = (inputs["problem 3"]["q"])

# inspiration from https://crypto.stackexchange.com/questions/13166/method-to-calculating-e-in-rsa
n = p * q
l = lcm(p - 1, q - 1)

e_list = []
e = 2

while e < l:
    if math.gcd(e, l) == 1:
        e_list.append(e)
        e = e + 1
    else:
        e = e + 1

small_e = e_list[0]
#print(small_e)
#print(l)

d=modinv(small_e,l)

#print(d)
outputs["problem 3"] = d



## problem 4
##
##    "problem 4" :
##    {
##	"e" : 7,
##	"n" : 77,
##	"x" : 20
##    },
##  OUTPUT:     "problem 4" : 48,

input4 = (inputs["problem 4"])

outputs["problem 4"] = "42"


## problem 5
##
##    "problem 5" :
##    {
##	   "p" : 7,
##	  "q" : 11,
##	   "y" : 48
##    }
##  OUTPUT:     "problem 5" : 20

input5 = (inputs["problem 5"])

#outputs["problem 5"] = "42"



#output
#json.dump(outputs, sys.stdout)
print(json.dumps(outputs, indent="  "))
print()
